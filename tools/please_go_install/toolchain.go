package main

import (
	"fmt"
	"path/filepath"
	"strings"
)

type toolchain struct {
	ccTool string
	goTool string
}

func fullPaths(ps []string, dir string) string {
	fullPs := make([]string, len(ps))
	for i, p := range ps {
		fullPs[i] = filepath.Join(dir, p)
	}
	return paths(fullPs)
}

func paths(ps []string) string {
	return strings.Join(ps, " ")
}

// cgo invokes go tool cgo to generate cgo sources and objects into the target directory
func (tc *toolchain) cgo(sourceDir string, objectDir string, cgoFiles []string) ([]string, []string) {
	goFiles := []string{"_cgo_gotypes.go"}
	var cFiles []string

	for _, cgoFile := range cgoFiles {
		goFiles = append(goFiles, strings.TrimSuffix(cgoFile, ".go")+".cgo1.go")
		cFiles = append(cFiles, strings.TrimSuffix(cgoFile, ".go")+".cgo2.c")
	}

	fmt.Printf("(cd %s; %s tool cgo -objdir $OLDPWD/%s %s)\n", sourceDir, tc.goTool, objectDir, paths(cgoFiles))

	return goFiles, cFiles
}

// goCompile will compile the go sources and the generated .cgo1.go sources for the cgo files (if any)
func (tc *toolchain) goCompile(dir, importcfg, out string, goFiles []string) {
	fmt.Printf("%s tool compile -pack -importcfg %s -o %s %s\n", tc.goTool, importcfg, out, fullPaths(goFiles, dir))
}

// goCompile will compile the go sources and the generated .cgo1.go sources for the cgo files (if any)
func (tc *toolchain) goAsmCompile(dir, importcfg, out string, goFiles []string, asmH, symabys string) {
	fmt.Printf("%s tool compile -pack -importcfg %s -asmhdr %s -symabis %s -o %s %s\n", tc.goTool, importcfg, out, asmH, symabys, fullPaths(goFiles, dir))
}

// cCompile will compile c sources as well as the .cgo2.c files generated by go tool cgo (if any)
func (tc *toolchain) cCompile(dir string, cFiles []string, cFlags []string) []string {
	objFiles := []string{"_cgo_export.o"}

	for _, cFile := range cFiles {
		objFiles = append(objFiles, strings.TrimSuffix(cFile, ".c")+".o")
	}

	fmt.Printf("(cd %s; %s -Wno-error -Wno-unused-parameter -c %s -I . _cgo_export.c %s)\n", dir, tc.ccTool, strings.Join(cFlags, " "), paths(cFiles))

	return objFiles
}

func (tc *toolchain) pack(dir, out string, objFiles []string) {
	fmt.Printf("%s tool pack r %s %s\n", tc.goTool, out, fullPaths(objFiles, dir))
}

func (tc *toolchain) link(archive, out string) {
	fmt.Printf("%s tool link -importcfg %s -o %s %s", opts.GoTool, opts.ImportConfig, out, archive)
}

func (tc *toolchain) symabis(sourceDir, objectDir, pkg string, asmFiles []string) (string, string) {
	asmH := fmt.Sprintf("%s/go_asm.h", objectDir)
	symabis := fmt.Sprintf("%s/symabis", objectDir)

	// the gc toolchain does this
	fmt.Printf("touch %s\n", asmH)

	fmt.Printf("(cd %s; %s tool asm -p %s -I . -I %s/pkg/include -D GOOS_%s -D GOARCH_%s -gensymabis -o $OLDPWD/%s %s)\n", sourceDir, opts.GoTool, pkg, opts.GOROOT, opts.GOOS, opts.GOARCH, symabis, paths(asmFiles))

	return asmH, symabis
}

func (tc *toolchain) asm(sourceDir, objectDir, pkg string, asmFiles []string) []string {
	var objFiles []string

	for _, asmFile := range asmFiles {
		objFile := strings.TrimSuffix(asmFile, ".s") + ".o"
		objFiles = append(objFiles, objFile)

		fmt.Printf("(cd %s; %s tool asm -p %s -I . -I %s/pkg/include -D GOOS_%s -D GOARCH_%s -o $OLDPWD/%s/%s %s)\n", sourceDir, opts.GoTool, pkg, opts.GOROOT, opts.GOOS, opts.GOARCH, objectDir, objFile, asmFile)
	}

	return objFiles
}
